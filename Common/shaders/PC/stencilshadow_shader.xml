<?xml version="1.0" encoding="utf-8" ?>
<shader rendertype="stencilshadow" skinned="no" vertexcolor="no" texcoord="no" debuginfo="no">

	<!-- shadow volumes are pre-extruded on the CPU -->
	<vertexshader name="vs1_preextended" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	dcl_position	V_POS

	mul R_POS, c[C_POS_DECOMPRESS0], V_POS
	add R_POS, c[C_POS_DECOMPRESS1], R_POS

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z

	; volume is pre-projected
	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- 
	This shader will extrude shadow geometry in the vertex shader.  A triangle is extruded
	if the dot product of the normal and the extension direction (-light direction) is greater than 0 (normal . extension > 0).
	If the condition fails the triangle will become degenerate and will be culled away.
	-->
	<vertexshader name="vs1_extend_directional" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	dcl_position	V_POS
	dcl_normal		V_NORMAL

	#define R_WORLD_NORMAL r11

	mul R_POS, c[C_POS_DECOMPRESS0], V_POS
	add R_POS, c[C_POS_DECOMPRESS1], R_POS
	mad R_NORMAL.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_DIRECTIONAL(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN+1].x, c[C_CUSTOM_MIN+1].y, R_TEMP)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- 
		For GPU extruded HARD skinned shadow volumes.  Each vertex has a vertex weight
		and a face weight in which to transform the normal.  The transformed normal is then
		used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_hardskin_facenormal_directional" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_INDICES	v1
	#define V_NORMAL	v2
	#define R_INDICES	r8
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_normal			V_NORMAL
	dcl_blendindices	V_INDICES

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mad R_TEMP2.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www

	; hard skin the position
	HARD_SKIN_POSITION(R_POS, R_INDICES.x, R_TEMP)

	; hard skin the normal
	HARD_SKIN_NORMAL(R_NORMAL, V_INDICES.y, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_DIRECTIONAL(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN+1].x, c[C_CUSTOM_MIN+1].y, R_TEMP)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- 
		For GPU extruded HARD skinned shadow volumes.  Each vertex has 3 other face vertices
		which are skinned and then a normal is generated by taking the cross product.  The transformed normal 
		is then used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_hardskin_generatenormal_directional" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_INDICES	v1
	#define V_POS2		v2
	#define V_POS3		v3

	#define R_INDICES	r5
	#define R_POS2		r6
	#define R_POS3		r7
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_blendindices	V_INDICES
	dcl_position1		V_POS2
	dcl_position2		V_POS3

	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 1
	HARD_SKIN_POSITION(R_POS, R_INDICES.x, R_TEMP)

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS2
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 2
	HARD_SKIN_POSITION(R_POS2, R_INDICES.y, R_TEMP)

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS3
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 3
	HARD_SKIN_POSITION(R_POS3, R_INDICES.z, R_TEMP)

	; take the cross product to calculate the normal (v2-v1) x (v0-v1)
	add R_TEMP2.xyz, R_POS, -R_POS2
	add R_TEMP.xyz, R_POS3, -R_POS2
	CROSS_PRODUCT(R_NORMAL, R_TEMP, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_DIRECTIONAL(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN+1].x, c[C_CUSTOM_MIN+1].y, R_TEMP)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>


	<!-- 
		For GPU extruded SOFT skinned shadow volumes.  Each vertex has a vertex weight
		and a face weight in which to transform the normal.  The transformed normal is then
		used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_softskin_facenormal_directional" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_WEGIHTS	v1
	#define V_INDICES	v2
	#define V_NORMAL	v3
	#define V_FWEIGHTS	v4
	#define V_FINDICES  v5

	#define R_INDICES	r5
	#define R_SKIN_M0	r6
	#define R_SKIN_M1	r7
	#define R_SKIN_M2	r8
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_blendweight		V_WEIGHTS
	dcl_blendindices	V_INDICES
	dcl_normal			V_NORMAL
	dcl_blendweight1	V_FWEIGHTS
	dcl_blendindices1	V_FINDICES

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www

	; skin the position
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS.x, R_TEMP, R_SKIN_M0
	dp4 R_POS.y, R_TEMP, R_SKIN_M1
	dp4 R_POS.z, R_TEMP, R_SKIN_M2
	mov R_POS.w, c[C_CONST0].z
								
	mul R_INDICES.xyz, V_FINDICES.xyz, c[C_CONST1].www
	mad R_TEMP.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy

	; skin the normal
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_FWEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	; transform normal to object space
	dp3 R_NORMAL.x, R_SKIN_M0, R_TEMP
	dp3 R_NORMAL.y, R_SKIN_M1, R_TEMP
	dp3 R_NORMAL.z, R_SKIN_M2, R_TEMP

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_DIRECTIONAL(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN+1].x, c[C_CUSTOM_MIN+1].y, R_TEMP)

	; project into screen space
	POS_PROJECT(oPos)
	</vertexshader>


	<!-- 
		For GPU extruded SOFT skinned shadow volumes.  Each vertex has 3 other face vertices
		which are skinned and then a normal is generated by taking the cross product.  The transformed normal 
		is then used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_softskin_generatenormal_directional" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_WEGIHTS	v1
	#define V_INDICES	v2
	#define V_POS2		v3
	#define V_WEIGHTS2	v4
	#define V_INDICES2  v5
	#define V_POS3		v6
	#define V_WEIGHTS3	v7
	#define V_INDICES3  v8

	#define R_INDICES	r5
	#define R_POS2		r6
	#define R_POS3		r7
	#define R_SKIN_M0	r8
	#define R_SKIN_M1	r9
	#define R_SKIN_M2	r11

	dcl_position		V_POS
	dcl_blendweight		V_WEIGHTS
	dcl_blendindices	V_INDICES
	dcl_position1		V_POS2
	dcl_blendweight1	V_WEIGHTS2
	dcl_blendindices1	V_INDICES2
	dcl_position2		V_POS3
	dcl_blendweight2	V_WEIGHTS3
	dcl_blendindices2	V_INDICES3

	; skin position 1
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS.x, R_TEMP, R_SKIN_M0
	dp4 R_POS.y, R_TEMP, R_SKIN_M1
	dp4 R_POS.z, R_TEMP, R_SKIN_M2
	mov R_POS.w, c[C_CONST0].z

	; skin position 2
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS2
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES2.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS2, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS2.x, R_TEMP, R_SKIN_M0
	dp4 R_POS2.y, R_TEMP, R_SKIN_M1
	dp4 R_POS2.z, R_TEMP, R_SKIN_M2
	mov R_POS2.w, c[C_CONST0].z

	; skin position 3
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS3
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES3.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS3, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS3.x, R_TEMP, R_SKIN_M0
	dp4 R_POS3.y, R_TEMP, R_SKIN_M1
	dp4 R_POS3.z, R_TEMP, R_SKIN_M2
	mov R_POS3.w, c[C_CONST0].z

	; take the cross product to calculate the normal (v2-v1) x (v0-v1)
	add R_TEMP2.xyz, R_POS, -R_POS2
	add R_TEMP.xyz, R_POS3, -R_POS2
	CROSS_PRODUCT(R_NORMAL, R_TEMP, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_TEMP2.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_TEMP2.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_TEMP2.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_DIRECTIONAL(R_WORLD_POS, R_TEMP2, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN+1].x, c[C_CUSTOM_MIN+1].y, R_TEMP)

	; project into screen space
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- **************************** extruding from a point light ****************************** -->

	<!-- 
	This shader will extrude shadow geometry in the vertex shader.  A triangle is extruded
	if the dot product of the normal and the extension direction (-light direction) is greater than 0 (normal . extension > 0).
	If the condition fails the triangle will become degenerate and will be culled away.
	-->
	<vertexshader name="vs1_extend_point" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	dcl_position	V_POS
	dcl_normal		V_NORMAL

	#define R_WORLD_NORMAL r11

	mul R_POS, c[C_POS_DECOMPRESS0], V_POS
	add R_POS, c[C_POS_DECOMPRESS1], R_POS
	mad R_NORMAL.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_POINT(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN].w, c[C_CUSTOM_MIN+1].x, R_TEMP, R_TEMP1)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- 
		For GPU extruded HARD skinned shadow volumes.  Each vertex has a vertex weight
		and a face weight in which to transform the normal.  The transformed normal is then
		used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_hardskin_facenormal_point" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_INDICES	v1
	#define V_NORMAL	v2
	#define R_INDICES	r8
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_normal			V_NORMAL
	dcl_blendindices	V_INDICES

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mad R_TEMP2.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www

	; hard skin the position
	HARD_SKIN_POSITION(R_POS, R_INDICES.x, R_TEMP)

	; hard skin the normal
	HARD_SKIN_NORMAL(R_NORMAL, V_INDICES.y, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_POINT(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN].w, c[C_CUSTOM_MIN+1].x, R_TEMP, R_TEMP1)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>

	<!-- 
		For GPU extruded HARD skinned shadow volumes.  Each vertex has 3 other face vertices
		which are skinned and then a normal is generated by taking the cross product.  The transformed normal 
		is then used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_hardskin_generatenormal_point" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_INDICES	v1
	#define V_POS2		v2
	#define V_POS3		v3

	#define R_INDICES	r5
	#define R_POS2		r6
	#define R_POS3		r7
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_blendindices	V_INDICES
	dcl_position1		V_POS2
	dcl_position2		V_POS3

	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 1
	HARD_SKIN_POSITION(R_POS, R_INDICES.x, R_TEMP)

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS2
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 2
	HARD_SKIN_POSITION(R_POS2, R_INDICES.y, R_TEMP)

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS3
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP

	; hard skin position 3
	HARD_SKIN_POSITION(R_POS3, R_INDICES.z, R_TEMP)

	; take the cross product to calculate the normal (v2-v1) x (v0-v1)
	add R_TEMP2.xyz, R_POS, -R_POS2
	add R_TEMP.xyz, R_POS3, -R_POS2
	CROSS_PRODUCT(R_NORMAL, R_TEMP, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_POINT(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN].w, c[C_CUSTOM_MIN+1].x, R_TEMP, R_TEMP1)

	; project into screen space 
	POS_PROJECT(oPos)
	</vertexshader>


	<!-- 
		For GPU extruded SOFT skinned shadow volumes.  Each vertex has a vertex weight
		and a face weight in which to transform the normal.  The transformed normal is then
		used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_softskin_facenormal_point" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_WEGIHTS	v1
	#define V_INDICES	v2
	#define V_NORMAL	v3
	#define V_FWEIGHTS	v4
	#define V_FINDICES  v5

	#define R_INDICES	r5
	#define R_SKIN_M0	r6
	#define R_SKIN_M1	r7
	#define R_SKIN_M2	r8
	#define R_WORLD_NORMAL r11

	dcl_position		V_POS
	dcl_blendweight		V_WEIGHTS
	dcl_blendindices	V_INDICES
	dcl_normal			V_NORMAL
	dcl_blendweight1	V_FWEIGHTS
	dcl_blendindices1	V_FINDICES

	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www

	; skin the position
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS.x, R_TEMP, R_SKIN_M0
	dp4 R_POS.y, R_TEMP, R_SKIN_M1
	dp4 R_POS.z, R_TEMP, R_SKIN_M2
	mov R_POS.w, c[C_CONST0].z
								
	mul R_INDICES.xyz, V_FINDICES.xyz, c[C_CONST1].www
	mad R_TEMP.xyz, V_NORMAL.xyz, c[C_NORMALTEX_DECOMPRESS].xxx, c[C_NORMALTEX_DECOMPRESS].yyy

	; skin the normal
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_FWEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	; transform normal to object space
	dp3 R_NORMAL.x, R_SKIN_M0, R_TEMP
	dp3 R_NORMAL.y, R_SKIN_M1, R_TEMP
	dp3 R_NORMAL.z, R_SKIN_M2, R_TEMP

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_POINT(R_WORLD_POS, R_WORLD_NORMAL, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN].w, c[C_CUSTOM_MIN+1].x, R_TEMP, R_TEMP1)

	; project into screen space
	POS_PROJECT(oPos)
	</vertexshader>


	<!-- 
		For GPU extruded SOFT skinned shadow volumes.  Each vertex has 3 other face vertices
		which are skinned and then a normal is generated by taking the cross product.  The transformed normal 
		is then used to decided whether or not to extend the vertex 
	-->
	<vertexshader name="vs1_extend_softskin_generatenormal_point" target="vs_1_1">
	#include "pcRedVertexShaderMacros.h"
	#include "pcRedVertexShaderConstants.h"

	#define V_POS		v0
	#define V_WEGIHTS	v1
	#define V_INDICES	v2
	#define V_POS2		v3
	#define V_WEIGHTS2	v4
	#define V_INDICES2  v5
	#define V_POS3		v6
	#define V_WEIGHTS3	v7
	#define V_INDICES3  v8

	#define R_INDICES	r5
	#define R_POS2		r6
	#define R_POS3		r7
	#define R_SKIN_M0	r8
	#define R_SKIN_M1	r9
	#define R_SKIN_M2	r11

	dcl_position		V_POS
	dcl_blendweight		V_WEIGHTS
	dcl_blendindices	V_INDICES
	dcl_position1		V_POS2
	dcl_blendweight1	V_WEIGHTS2
	dcl_blendindices1	V_INDICES2
	dcl_position2		V_POS3
	dcl_blendweight2	V_WEIGHTS3
	dcl_blendindices2	V_INDICES3

	; skin position 1
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS.x, R_TEMP, R_SKIN_M0
	dp4 R_POS.y, R_TEMP, R_SKIN_M1
	dp4 R_POS.z, R_TEMP, R_SKIN_M2
	mov R_POS.w, c[C_CONST0].z

	; skin position 2
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS2
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES2.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS2, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS2.x, R_TEMP, R_SKIN_M0
	dp4 R_POS2.y, R_TEMP, R_SKIN_M1
	dp4 R_POS2.z, R_TEMP, R_SKIN_M2
	mov R_POS2.w, c[C_CONST0].z

	; skin position 3
	mul R_TEMP, c[C_POS_DECOMPRESS0], V_POS3
	add R_TEMP, c[C_POS_DECOMPRESS1], R_TEMP
	mul R_INDICES.xyz, V_INDICES3.xyz, c[C_CONST1].www
	GET_SOFT_SKIN_MATRIX(R_INDICES, V_WEIGHTS3, R_SKIN_M0, R_SKIN_M1, R_SKIN_M2, R_TEMP1)
	dp4 R_POS3.x, R_TEMP, R_SKIN_M0
	dp4 R_POS3.y, R_TEMP, R_SKIN_M1
	dp4 R_POS3.z, R_TEMP, R_SKIN_M2
	mov R_POS3.w, c[C_CONST0].z

	; take the cross product to calculate the normal (v2-v1) x (v0-v1)
	add R_TEMP2.xyz, R_POS, -R_POS2
	add R_TEMP.xyz, R_POS3, -R_POS2
	CROSS_PRODUCT(R_NORMAL, R_TEMP, R_TEMP2)

	; transform pos to world space
	dp4 R_WORLD_POS.x, R_POS, c[C_OBJ_WORLD_M0]
	dp4 R_WORLD_POS.y, R_POS, c[C_OBJ_WORLD_M1]
	dp4 R_WORLD_POS.z, R_POS, c[C_OBJ_WORLD_M2]
	mov R_WORLD_POS.w, c[C_CONST0].z
	; transform normal to world space
	dp3 R_TEMP2.x, R_NORMAL, c[C_OBJ_WORLD_M0]
	dp3 R_TEMP2.y, R_NORMAL, c[C_OBJ_WORLD_M1]
	dp3 R_TEMP2.z, R_NORMAL, c[C_OBJ_WORLD_M2]

	; extrude position
	SHADOW_EXTRUDE_POINT(R_WORLD_POS, R_TEMP2, c[C_CUSTOM_MIN], c[C_CUSTOM_MIN].w, c[C_CUSTOM_MIN+1].x, R_TEMP, R_TEMP1)

	; project into screen space
	POS_PROJECT(oPos)
	</vertexshader>



	<pixelshader name="ps1" target="ps_1_1">
	mov r0, c0
	</pixelshader>

	<pipeline id="1">

		<state id="0">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_preextended"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>


		<!-- directional light states -->

		<state id="1">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_directional"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="2">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_facenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="3">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_generatenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="4">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_facenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="5">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_generatenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>


		<!-- point light states -->

		<state id="6">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="7">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_facenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="8">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_generatenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="9">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_facenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="10">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_generatenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>


		<!-- 2 pass states: directional/point mix first pass is always the directional light -->

		<state id="11">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_directional"/>
				<pixelshader use="ps1"/>
			</pass>
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="12">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_facenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_facenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="13">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_generatenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_hardskin_generatenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="14">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_facenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_facenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>
		<state id="15">
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_generatenormal_directional"/>
				<pixelshader use="ps1"/>
			</pass>
			<pass transform="none" lighting="none">
				<vertexshader use="vs1_extend_softskin_generatenormal_point"/>
				<pixelshader use="ps1"/>
			</pass>
		</state>

	</pipeline>
</shader>