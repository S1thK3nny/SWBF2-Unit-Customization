<?xml version="1.0" encoding="utf-8"?>
<shader rendertype="bump" skinned="yes" debuginfo="no">

	<!-- ****************************** Vertex Lit Vertex Shaders ****************************** -->

	<vertexshader name="vs1_far" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; output color (with lighting)
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		mov oD0.w, R_MATERIAL_COLOR.w

		; output fog value in oFog
		dp4 R_TEMP.z, R_WORLD_POS, c[C_WORLD_PROJ_M3]
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
	</vertexshader>

	<vertexshader name="vs1_near_opaque" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; output color with lighting and near scene fade
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<vertexshader name="vs1_near_opaque_shadow" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; transform shadow map coordinates
		dp4 oT1.x, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_U]
		dp4 oT1.y, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_V]
		dp4 oT1.w, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_W]
		mov oT1.z, c[C_CONST0].x

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; output lighting minus sun to oD0, sun lighting to oD1
		add R_DIFFUSE_LIGHTING.xyz, R_DIFFUSE_LIGHTING.xyz, -R_DIFFUSE_DIRECTIONAL_LIGHTING_COLOR.xyz
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		mul oD1.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_DIRECTIONAL_LIGHTING_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<vertexshader name="vs1_near_transparent" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; clamp to [0.0,1.0] and square it to fade transparent objects faster
		max R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		min R_TEMP.w, R_TEMP.w, c[C_CONST0].z
		mul R_TEMP.w, R_TEMP.w, R_TEMP.w
		; output color with lighting and near scene fade
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		mul oD0.w, R_MATERIAL_COLOR.w, R_TEMP.w
	</vertexshader>

	<vertexshader name="vs1_near_transparent_shadow" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; transform shadow map coordinates
		dp4 oT1.x, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_U]
		dp4 oT1.y, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_V]
		dp4 oT1.w, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_W]
		mov oT1.z, c[C_CONST0].x

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; clamp to [0.0,1.0] and square it to fade transparent objects faster
		max R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		min R_TEMP.w, R_TEMP.w, c[C_CONST0].z
		mul R_TEMP.w, R_TEMP.w, R_TEMP.w
		; output lighting minus sun to oD0, sun lighting to oD1
		add R_DIFFUSE_LIGHTING.xyz, R_DIFFUSE_LIGHTING.xyz, -R_DIFFUSE_DIRECTIONAL_LIGHTING_COLOR.xyz
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		mul oD1.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_DIRECTIONAL_LIGHTING_COLOR.xyz
		mul oD0.w, R_MATERIAL_COLOR.w, R_TEMP.w
	</vertexshader>

	<vertexshader name="vs1_near_opaque_specular" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL r11

		; project the position into screen space		
		POS_PROJECT(oPos)

		; transform normal to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; calculate the reflected eye-to-vertex vector
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_WORLD_VIEWPOS].xyz
		dp3 R_TEMP.w, R_TEMP.xyz, R_WORLD_NORMAL.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz

		; calculate specular spot map projected coordinates
		dp3 R_TEMP1.x, R_TEMP.xyz, c[C_CUSTOM_MIN+5].xyz
		dp3 R_TEMP1.y, R_TEMP.xyz, c[C_CUSTOM_MIN+6].xyz
		dp3 R_TEMP1.w, R_TEMP.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		; output biased coords (x+z, y+z, 0, z+z) => ((x/z + 1)/2, (y/z + 1)/2, 0, 1)
		add oT1.xyzw, R_TEMP1.xyww, R_TEMP1.wwww

		; calculate specular color = ((n dot -l) gte 0) ? c[C_SPECULAR_COLOR] : black
		dp3 R_TEMP.w, R_WORLD_NORMAL.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		sge R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		mul oD1.xyz, R_TEMP.w, c[C_CUSTOM_MIN+2].xyz

		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; output color with lighting and near scene fade
		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<vertexshader name="vs1_near_opaque_specular_shadow" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL r11

		; project the position into screen space		
		POS_PROJECT(oPos)

		; transform normal to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; calculate the reflected eye-to-vertex vector
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_WORLD_VIEWPOS].xyz
		dp3 R_TEMP.w, R_TEMP.xyz, R_WORLD_NORMAL.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz

		; calculate specular spot map projected coordinates
		dp3 R_TEMP1.x, R_TEMP.xyz, c[C_CUSTOM_MIN+5].xyz
		dp3 R_TEMP1.y, R_TEMP.xyz, c[C_CUSTOM_MIN+6].xyz
		dp3 R_TEMP1.w, R_TEMP.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		; output biased coords (x+z, y+z, 0, z+z) => ((x/z + 1)/2, (y/z + 1)/2, 0, 1)
		add oT1.xyzw, R_TEMP1.xyww, R_TEMP1.wwww

		; calculate specular color = ((n dot -l) gte 0) ? c[C_SPECULAR_COLOR] : black
		dp3 R_TEMP.w, R_WORLD_NORMAL.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		sge R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		mul oD1.xyz, R_TEMP.w, c[C_CUSTOM_MIN+2].xyz

		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; transform shadow map coordinates
		dp4 oT2.x, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_U]
		dp4 oT2.y, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_V]
		dp4 oT2.w, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_W]
		mov oT2.z, c[C_CONST0].x

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
//		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
//		mov oT3.xyzw, R_DIFFUSE_LIGHTING.w
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
//		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<vertexshader name="vs1_near_transparent_specular" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL r11

		; project the position into screen space		
		POS_PROJECT(oPos)

		; transform normal to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; calculate the reflected eye-to-vertex vector
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_WORLD_VIEWPOS].xyz
		dp3 R_TEMP.w, R_TEMP.xyz, R_WORLD_NORMAL.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz

		; calculate specular spot map projected coordinates
		dp3 R_TEMP1.x, R_TEMP.xyz, c[C_CUSTOM_MIN+5].xyz
		dp3 R_TEMP1.y, R_TEMP.xyz, c[C_CUSTOM_MIN+6].xyz
		dp3 R_TEMP1.w, R_TEMP.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		; output biased coords (x+z, y+z, 0, z+z) => ((x/z + 1)/2, (y/z + 1)/2, 0, 1)
		add oT1.xyzw, R_TEMP1.xyww, R_TEMP1.wwww

		; calculate specular color = ((n dot -l) gte 0) ? c[C_SPECULAR_COLOR] : black
		dp3 R_TEMP.w, R_WORLD_NORMAL.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		sge R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		mul oD1.xyz, R_TEMP.w, c[C_CUSTOM_MIN+2].xyz

		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; clamp to [0.0,1.0] and square it to fade transparent objects faster
		max R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		min R_TEMP.w, R_TEMP.w, c[C_CONST0].z
		mul R_TEMP.w, R_TEMP.w, R_TEMP.w
		; output color with lighting and near scene fade
//		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
//		mul oD0.w, R_MATERIAL_COLOR.w, R_TEMP.w
	</vertexshader>

	<vertexshader name="vs1_near_transparent_specular_shadow" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL r11

		; project the position into screen space		
		POS_PROJECT(oPos)

		; transform normal to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; calculate the reflected eye-to-vertex vector
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_WORLD_VIEWPOS].xyz
		dp3 R_TEMP.w, R_TEMP.xyz, R_WORLD_NORMAL.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz
		mad R_TEMP.xyz,-R_TEMP.w, R_WORLD_NORMAL.xyz, R_TEMP.xyz

		; calculate specular spot map projected coordinates
		dp3 R_TEMP1.x, R_TEMP.xyz, c[C_CUSTOM_MIN+5].xyz
		dp3 R_TEMP1.y, R_TEMP.xyz, c[C_CUSTOM_MIN+6].xyz
		dp3 R_TEMP1.w, R_TEMP.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		; output biased coords (x+z, y+z, 0, z+z) => ((x/z + 1)/2, (y/z + 1)/2, 0, 1)
		add oT1.xyzw, R_TEMP1.xyww, R_TEMP1.wwww

		; calculate specular color = ((n dot -l) gte 0) ? c[C_SPECULAR_COLOR] : black
		dp3 R_TEMP.w, R_WORLD_NORMAL.xyz,-c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		sge R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		mul oD1.xyz, R_TEMP.w, c[C_CUSTOM_MIN+2].xyz

		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; transform shadow map coordinates
		dp4 oT2.x, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_U]
		dp4 oT2.y, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_V]
		dp4 oT2.w, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_W]
		mov oT2.z, c[C_CONST0].x

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		FOG(R_TEMP.z, R_WORLD_POS, R_TEMP1)
		; clamp to [0.0,1.0] and square it to fade transparent objects faster
//		max R_TEMP.w, R_TEMP.w, c[C_CONST0].x
//		min R_TEMP.w, R_TEMP.w, c[C_CONST0].z
//		mul R_TEMP.w, R_TEMP.w, R_TEMP.w
//		mul oD0.xyz, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.xyz
//		mul oT3.xyzw, R_MATERIAL_COLOR.xyz, R_DIFFUSE_LIGHTING.w
//		mul oD0.w, R_MATERIAL_COLOR.w, R_TEMP.w
	</vertexshader>

	<!-- ****************************** Pixel Lit Vertex Shaders ****************************** -->

	<vertexshader name="vs1_pixellit_1light_near_opaque" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL     r11

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 R_TEMP2.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 R_TEMP2.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov R_TEMP2.zw, c[C_CONST0].xz

		mov oT0, R_TEMP2
		mov oT1, R_TEMP2

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output color with lighting and near scene fade
		mov oD0.xyz, R_MATERIAL_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z

		; transform normal and binormals to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_S.xyz
		dp3 R_BINORMAL_S.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_S.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_S.z, R_TEMP, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_T.xyz
		dp3 R_BINORMAL_T.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_T.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_T.z, R_TEMP, c[C_OBJ_WORLD_M2]

		; calculate light0 space coordinates = (v.pos - l0.pos)/(l0.range)
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+3].xyz
		mul R_TEMP.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN+3].w
		; rotate light into tangent space
		dp3 R_TEMP2.x, R_TEMP, R_BINORMAL_S
		dp3 R_TEMP2.y, R_TEMP, R_BINORMAL_T
		dp3 R_TEMP2.z, R_TEMP, R_WORLD_NORMAL
		; calculate light1 volume texture coordinates by biasing this _bx2
		mad oT2.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y

		; rotate the sun into tangent space
		dp3 R_TEMP.x, -c[C_LIGHT_DIRECTIONAL0_DIR], R_BINORMAL_S
		dp3 R_TEMP.y, -c[C_LIGHT_DIRECTIONAL0_DIR], R_BINORMAL_T
		dp3 R_TEMP.z, -c[C_LIGHT_DIRECTIONAL0_DIR], R_WORLD_NORMAL
		; don't bump map the unlit side of objects to avoid glittering in shadows
		sge R_TEMP.w, R_TEMP.z, c[C_CONST0].x
		mul R_TEMP.xyz, R_TEMP.xyz, R_TEMP.w

		; calculate sun direction by biasing this _bx2
		mad oD1.xyz, R_TEMP.xyz, c[C_CONST0].y, c[C_CONST0].y
	</vertexshader>

	<vertexshader name="vs1_pixellit_1light_near_opaque_shadow" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL     r11

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 R_TEMP2.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 R_TEMP2.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov R_TEMP2.zw, c[C_CONST0].xz

		mov oT0, R_TEMP2
		mov oT1, R_TEMP2

		; transform shadow map coordinates
		dp4 oT2.x, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_U]
		dp4 oT2.y, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_V]
		dp4 oT2.w, R_WORLD_POS, c[C_SHADOWMAP_TRANSFORM_W]
		mov oT2.z, c[C_CONST0].x

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output color with lighting and near scene fade
		mov oD0.xyz, R_MATERIAL_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z

		; transform normal and binormals to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_S.xyz
		dp3 R_BINORMAL_S.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_S.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_S.z, R_TEMP, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_T.xyz
		dp3 R_BINORMAL_T.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_T.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_T.z, R_TEMP, c[C_OBJ_WORLD_M2]

		; calculate light0 space coordinates = (v.pos - l0.pos)/(l0.range)
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+3].xyz
		mul R_TEMP.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN+3].w
		; rotate light into tangent space
		dp3 R_TEMP2.x, R_TEMP, R_BINORMAL_S
		dp3 R_TEMP2.y, R_TEMP, R_BINORMAL_T
		dp3 R_TEMP2.z, R_TEMP, R_WORLD_NORMAL
		; calculate light1 volume texture coordinates by biasing this _bx2
		mad oT3.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y

		; rotate the sun into tangent space
		dp3 R_TEMP.x, -c[C_LIGHT_DIRECTIONAL0_DIR], R_BINORMAL_S
		dp3 R_TEMP.y, -c[C_LIGHT_DIRECTIONAL0_DIR], R_BINORMAL_T
		dp3 R_TEMP.z, -c[C_LIGHT_DIRECTIONAL0_DIR], R_WORLD_NORMAL
		; don't bump map the unlit side of objects to avoid glittering in shadows
		sge R_TEMP.w, R_TEMP.z, c[C_CONST0].x
		mul R_TEMP.xyz, R_TEMP.xyz, R_TEMP.w

		; calculate sun direction by biasing this _bx2
		mad oD1.xyz, R_TEMP.xyz, c[C_CONST0].y, c[C_CONST0].y
	</vertexshader>

	<vertexshader name="vs1_pixellit_0lights_staticlit_near_opaque" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 R_TEMP2.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 R_TEMP2.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov R_TEMP2.zw, c[C_CONST0].xz

		mov oT0, R_TEMP2

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output static lighting and near scene fade
		mov oD0.xyz, R_STATIC_DIFFUSE_LIGHTING.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<vertexshader name="vs1_pixellit_2lights_nosun_near_opaque" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL     r11

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 R_TEMP2.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 R_TEMP2.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov R_TEMP2.zw, c[C_CONST0].xz

		mov oT0, R_TEMP2
		mov oT1, R_TEMP2

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output color with lighting and near scene fade
		mov oD0.xyz, R_MATERIAL_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
		; output static lighting to oD1
		mov oD1.xyz, R_STATIC_DIFFUSE_LIGHTING.xyz

		; transform normal and binormals to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_S.xyz
		dp3 R_BINORMAL_S.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_S.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_S.z, R_TEMP, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_T.xyz
		dp3 R_BINORMAL_T.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_T.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_T.z, R_TEMP, c[C_OBJ_WORLD_M2]

		; calculate light0 space coordinates = (v.pos - l0.pos)/(l0.range)
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+3].xyz
		mul R_TEMP.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN+3].w
		; rotate light into tangent space
		dp3 R_TEMP2.x, R_TEMP, R_BINORMAL_S
		dp3 R_TEMP2.y, R_TEMP, R_BINORMAL_T
		dp3 R_TEMP2.z, R_TEMP, R_WORLD_NORMAL
		; calculate light1 volume texture coordinates by biasing this _bx2
		mad oT2.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y

		; calculate light1 space coordinates = (v.pos - l1.pos)/(l1.range)
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+4].xyz
		mul R_TEMP.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN+4].w
		; rotate light into tangent space
		dp3 R_TEMP2.x, R_TEMP, R_BINORMAL_S
		dp3 R_TEMP2.y, R_TEMP, R_BINORMAL_T
		dp3 R_TEMP2.z, R_TEMP, R_WORLD_NORMAL
		; calculate light1 volume texture coordinates by biasing this _bx2
		mad oT3.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y
	</vertexshader>

	<vertexshader name="vs1_pixellit_2lights_near_opaque" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		; project the position into screen space		
		POS_PROJECT(oPos)
		
		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output color with lighting and near scene fade
		mov oD0.xyz, R_MATERIAL_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z

		; output world space normal to oT1.xyz to be renormalized by cube map
		dp3 oT1.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 oT1.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 oT1.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; calculate light0 space coordinates = (v.pos - l0.pos)/(l0.range)
		add R_TEMP.xyz, R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+3].xyz
		mul R_TEMP2.xyz, R_WORLD_TEMP.xyz, c[C_CUSTOM_MIN+3].w
		; calculate light volume texture coordinates by biasing this _bx2
		mad oT2.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y

		; calculate light1 space coordinates = (v.pos - l1.pos)/(l1.range)
		add R_TEMP.xyz,R_WORLD_POS.xyz,-c[C_CUSTOM_MIN+4].xyz
		mul R_TEMP2.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN+4].w
		; calculate light volume texture coordinates by biasing this _bx2
		mad oT3.xyz, R_TEMP2.xyz, c[C_CONST0].y, c[C_CONST0].y
	</vertexshader>

	<vertexshader name="vs1_pixellit_near_opaque_specular" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_HALF_VEC		r8
		#define R_LIGHT_X		r9
		#define R_LIGHT_Z		r10
		#define R_WORLD_NORMAL	r11

		; project the position into screen space		
		POS_PROJECT(oPos)

		; decompress texcoords
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw

		; transform texture coordinates
		dp4 oT0.x, R_TEMP, c[C_CUSTOM_MIN+0]
		dp4 oT0.y, R_TEMP, c[C_CUSTOM_MIN+1]
		mov oT0.zw, c[C_CONST0].xz

		; calculate the direction from the vertex to the eye
		add R_TEMP, c[C_WORLD_VIEWPOS], -R_WORLD_POS
		dp3 R_TEMP.w, R_TEMP.xyz, R_TEMP.xyz
		rsq R_TEMP.w, R_TEMP.w
		mul R_TEMP.xyz, R_TEMP.xyz, R_TEMP.w
		
		; calculate the half vector
		add R_HALF_VEC.xyz, R_TEMP.xyz, -c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		dp3 R_HALF_VEC.w, R_HALF_VEC.xyz, R_HALF_VEC.xyz
		rsq R_HALF_VEC.w, R_HALF_VEC.w
		mul R_HALF_VEC.xyz, R_HALF_VEC.xyz, R_HALF_VEC.w

		; transform normal to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]

		; write (-L dot N > 0) ? 1 : 0 to oD0.w
		dp3 R_TEMP.w, R_WORLD_NORMAL, -c[C_LIGHT_DIRECTIONAL0_DIR].xyz
		sge R_TEMP.w, R_TEMP.w, c[C_CONST0].x
		mul oD1.xyz, c[C_CUSTOM_MIN+2].xyz, R_TEMP.www

		; transform binormals to world space
		dp3 R_TEMP.x, R_BINORMAL_S, c[C_OBJ_WORLD_M0]
		dp3 R_TEMP.y, R_BINORMAL_S, c[C_OBJ_WORLD_M1]
		dp3 R_TEMP.z, R_BINORMAL_S, c[C_OBJ_WORLD_M2]
		dp3 R_TEMP1.x, R_BINORMAL_T, c[C_OBJ_WORLD_M0]
		dp3 R_TEMP1.y, R_BINORMAL_T, c[C_OBJ_WORLD_M1]
		dp3 R_TEMP1.z, R_BINORMAL_T, c[C_OBJ_WORLD_M2]

		; create light space lightY = half vector, lightZ = tangent x lightY
		mul R_LIGHT_Z, R_TEMP.zxy, R_HALF_VEC.yzx
		mad R_LIGHT_Z, R_TEMP.yzx, R_HALF_VEC.zxy, -R_LIGHT_Z

		; normalize
		dp3 R_LIGHT_Z.w, R_LIGHT_Z.xyz, R_LIGHT_Z.xyz
		rsq R_LIGHT_Z.w, R_LIGHT_Z.w
		mul R_LIGHT_Z.xyz, R_LIGHT_Z.xyz, R_LIGHT_Z.w

		; lightX = lightY x lightZ
		mul R_LIGHT_X, R_HALF_VEC.zxy, R_LIGHT_Z.yzx
		mad R_LIGHT_X, R_HALF_VEC.yzx, R_LIGHT_Z.zxy, -R_LIGHT_X

		; normalize
		dp3 R_LIGHT_X.w, R_LIGHT_X.xyz, R_LIGHT_X.xyz
		rsq R_LIGHT_X.w, R_LIGHT_X.w
		mul R_LIGHT_X.xyz, R_LIGHT_X.xyz, R_LIGHT_X.w

		mov oT1.w, c[C_CONST0].z
		mov oT2.w, c[C_CONST0].z
		mov oT3.w, c[C_CONST0].z

		; create a matrix that transforms tangent space into light space
		dp3 oT1.x, R_TEMP.xyz, R_LIGHT_X.xyz
		dp3 oT2.x, R_TEMP.xyz, R_HALF_VEC.xyz
		dp3 oT3.x, R_TEMP.xyz, R_LIGHT_Z.xyz

		dp3 oT1.y, R_TEMP1.xyz, R_LIGHT_X.xyz
		dp3 oT2.y, R_TEMP1.xyz, R_HALF_VEC.xyz
		dp3 oT3.y, R_TEMP1.xyz, R_LIGHT_Z.xyz

		dp3 oT1.z, R_WORLD_NORMAL.xyz, R_LIGHT_X.xyz
		dp3 oT2.z, R_WORLD_NORMAL.xyz, R_HALF_VEC.xyz
		dp3 oT3.z, R_WORLD_NORMAL.xyz, R_LIGHT_Z.xyz
	</vertexshader>

	<vertexshader name="vs1_debug" target="vs_1_1">
		#include "pcRedVertexShaderMacros.h"

		#define R_WORLD_NORMAL     r11

		; transform normal and binormals to world space
		dp3 R_WORLD_NORMAL.x, R_NORMAL, c[C_OBJ_WORLD_M0]
		dp3 R_WORLD_NORMAL.y, R_NORMAL, c[C_OBJ_WORLD_M1]
		dp3 R_WORLD_NORMAL.z, R_NORMAL, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_S.xyz
		dp3 R_BINORMAL_S.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_S.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_S.z, R_TEMP, c[C_OBJ_WORLD_M2]
		mov R_TEMP.xyz, R_BINORMAL_T.xyz
		dp3 R_BINORMAL_T.x, R_TEMP, c[C_OBJ_WORLD_M0]
		dp3 R_BINORMAL_T.y, R_TEMP, c[C_OBJ_WORLD_M1]
		dp3 R_BINORMAL_T.z, R_TEMP, c[C_OBJ_WORLD_M2]

		mul R_NORMAL.xyz, R_NORMAL.xyz, c[C_CUSTOM_MIN].x
		mad R_NORMAL.xyz, R_BINORMAL_S.xyz, c[C_CUSTOM_MIN].y, R_NORMAL.xyz
		mad R_NORMAL.xyz, R_BINORMAL_T.xyz, c[C_CUSTOM_MIN].z, R_NORMAL.xyz
		mul R_TEMP, V_TEXCOORDS, c[C_NORMALTEX_DECOMPRESS].zzzw
		mov R_TEMP.z, c[C_CONST0].x
		mad R_NORMAL.xyz, R_TEMP.xyz, c[C_CUSTOM_MIN].w, R_NORMAL.xyz

		; write debug value biased to R_NORMAL
		mad oT0.xyz, R_NORMAL.xyz, c[C_CONST0].yyy, c[C_CONST0].yyy

		; project the position into screen space		
		POS_PROJECT(oPos)

		; calculate near scene fade factor in R_TEMP.w
		NEARSCENEFADE(R_TEMP)
		; output color with lighting and near scene fade
		mov oD0.xyz, R_MATERIAL_COLOR.xyz
		; output fade factor * 0.25 + 0.5 to allow interpolation outside the range 0-1
		mad oD0.w, R_TEMP.w, c[C_CONST1].y, c[C_CONST1].z
	</vertexshader>

	<!-- ****************************** Vertex Lit Pixel Shaders ****************************** -->

	<pixelshader name="ps1_far" target="ps_1_1">
		tex t0	// diffuse map

		mul r0, t0, v0
	</pixelshader>

	<pixelshader name="ps1_near_opaque" target="ps_1_1">
		tex t0	// diffuse map

		// r0 = main * lighting
		mul r0.rgb,t0,v0
		mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_hardedged" target="ps_1_1">
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0
		tex t0	// diffuse map

		mul r0.rgb,t0,v0
		+add r0.a,t0_bias.a,c7.b
		cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_transparent" target="ps_1_1">
		tex t0	// diffuse map

		mul r0.rgb,t0,v0
		+mul r0.a,t0.a,v0.a
	</pixelshader>

	<pixelshader name="ps1_near_transparent_hardedged" target="ps_1_1">
		def c7, 0, 0, 0.5, 0		// 0, 0, 1-alpharef, 0
		tex t0	// diffuse map

		mul r1.rgb,t0.a,v0.a
		+add r0.a,t0_bias.a,c7.b
		mul r0.rgb,t0,v0
		+cnd r0.a,r0.a,r1.b,c7.a		// alpha test vs. alpharef
	</pixelshader>

	<pixelshader name="ps1_near_opaque_shadow" target="ps_1_1">
		tex t0	// diffuse map
		tex t1	// shadow map
		;v0.rgb = lighting - sun lighting
		;v1.rgb = sun lighting
		;v0.a = near scene fade factor d4 + 1/2

		// shadow corrected light = (diffuse lighting) + shadowmap*(sun contribution)
		mad_sat r0.rgb, t1.a, v1, v0

		// r0 = main * lighting + specular
		mul r0.rgb,t0,r0
		mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_hardedged_shadow" target="ps_1_1">
		def c7, 0, 0, 0.5, -0.01			// 0, 0, 1-alpharef, 0
		tex t0	// diffuse map
		tex t1	// shadow map
		;v0.rgb = lighting - sun lighting
		;v1.rgb = sun lighting
		;v0.a = near scene fade factor d4 + 1/2

		// shadow corrected light = (diffuse lighting) + shadowmap*(sun contribution)
		mad_sat r0.rgb, t1.a, v1, v0

		+add r0.a,t0_bias.a,c7.b
		mul r0.rgb,t0,r0
		cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_transparent_shadow" target="ps_1_1">
		tex t0	// diffuse map
		tex t1	// shadow map
		;v0.rgb = lighting - sun lighting
		;v1.rgb = sun lighting
		;v0.a = near scene fade factor d4 + 1/2

		// shadow corrected light = (diffuse lighting) + shadowmap*(sun contribution)
		mad_sat r0.rgb, t1.a, v1, v0
		mul r0.rgb,t0,r0
		+mul r0.a,t0.a,v0.a
	</pixelshader>

	<pixelshader name="ps1_near_transparent_hardedged_shadow" target="ps_1_1">
		def c7, 0, 0, 0.5, 0		// 0, 0, 1-alpharef, 0
		tex t0	// diffuse map
		tex t1	// shadow map
		;v0.rgb = lighting - sun lighting
		;v1.rgb = sun lighting
		;v0.a = near scene fade factor d4 + 1/2

		// shadow corrected light = (diffuse lighting) + shadowmap*(sun contribution)
		mad_sat r0.rgb, t1.a, v1, v0
		+mul r1.a,t0.a,v0.a
		mul r0.rgb,t0,r0
		+add r0.a,t0_bias.a,c7.b
		cnd r0.a,r0.a,r1.a,c7.a	// alpha test vs. alpharef
	</pixelshader>

	<pixelshader name="ps1_near_opaque_specular" target="ps_1_1">
		tex t0		// diffuse map, gloss in alpha
		tex t1		// specular spot

		mul r0.rgb,t0,v0		// diffuse color = lighting * diffuse map
		// add specular spot * specular color * gloss map
		mul r1.rgb,t1,v1
		mad r0.rgb,r1,t0.a,r0
		mov_x4 r0.a,v0_bias.a	// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_transparent_specular" target="ps_1_1">
		tex t0		// diffuse map, gloss and opacity in alpha
		tex t1		// specular spot

		mul r0.rgb,t0,v0		// diffuse color = lighting * diffuse map
		+mov r0.a, v0.a
		// add specular spot * specular color * gloss map
		mul r1.rgb,t1,v1
		mad r0.rgb,r1,t0.a,r0
	</pixelshader>

	<pixelshader name="ps1_near_opaque_specular_shadow" target="ps_1_1">
		tex t0		// diffuse map, gloss in alpha
		tex t1		// specular spot
		tex t2		// shadow map
		texcoord t3	// shadow atten
		;v0.rgb = lighting - sun lighting
		;v0.a = near scene fade factor d4 + 1/2
		;v1.rgb = specular lighting

		mul r0.rgb,t0,v0
		+mul r1.a, t3.a, 1-t2.a
		mul r0.rgb, r0, 1-r1.a
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
		// add specular spot * specular color * gloss map
		mul r1.rgb,t1,v1
		+mul r1.a, 1-r1.a, t0.a
	</pixelshader>

	<pixelshader name="ps1_near_transparent_specular_shadow" target="ps_1_1">
		tex t0		// diffuse map, gloss in alpha
		tex t1		// specular spot
		tex t2		// shadow map
		texcoord t3	// sun lighting
		;v0.rgb = lighting - sun lighting
		;v0.a = near scene fade factor d4 + 1/2
		;v1.rgb = specular lighting

		// shadow corrected light = (diffuse lighting) + shadowmap*(sun contribution)
		mad_sat r0.rgb, t1.a, t3, v0

		mul r0.rgb,t0,r0		// diffuse color = lighting * diffuse map
		+mov r0.a,v0.a
		// add specular spot * specular color * gloss map
		mul r1.rgb,t1,v1
		+mul r1.a, t3.a, t0.a
		mad r0.rgb,r1,r1.a,r0
	</pixelshader>

	<!-- ****************************** Pixel Lit Pixel Shaders ****************************** -->

	<pixelshader name="ps1_near_pixellit_0lights_opaque" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color

		tex t0	// diffuse map
		tex t1  // normal map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r1 = (N dot -L0)
		dp3_sat r1, t1_bx2, r0
		
		; add directional and ambient contribution
		mul r0, t0, v0
		mad_sat r1.rgb, r1, c1, c0
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
		mul r0.rgb, r1, r0
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_0lights_opaque_shadow" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// shadow map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r1 = (N dot -L0)
		dp3_sat r1, t1_bx2, r0
		
		; modulate sun attenuation by shadow map
		mul r1.rgb, r1, t2.a
	
		; add directional and ambient contribution
		mul r0, t0, v0
		mad_sat r1.rgb, r1, c1, c0
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
		mul r0.rgb, r1, r0
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_0lights_hardedged" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // normal map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r1 = (N dot -L0)
		dp3_sat r1, t1_bx2, r0_bx2
	
		; add directional and ambient contribution
		mul r0.rgb, t0, v0
		+add r0.a,t0_bias.a,c7.b
		mad_sat r1.rgb, r1, c1, c0
		+cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
		mul r0.rgb, r1, r0
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_0lights_hardedged_shadow" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// shadow map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r1 = (N dot -L0)
		dp3_sat r1, t1_bx2, r0
		
		; modulate sun attenuation by shadow map
		mul_sat r1.rgb, r1, t2.a
	
		; add directional and ambient contribution
		mul r0.rgb, t0, v0
		+add r0.a,t0_bias.a,c7.b
		mad_sat r1.rgb, r1, c1, c0
		+cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
		mul r0.rgb, r1, r0
	</pixelshader>	

	<pixelshader name="ps1_near_pixellit_1lights_opaque" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// light map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r0.rgb = (N dot -sun)*sun.color*shadow + ambient
		dp3_sat r0, t1_bx2, r0
			; r0.rgb += (N dot -L0) *L0.atten*L0.color
			dp3_sat r1, t1_bx2, t2_bx2
				; r1.rgb = diffuse texture * material color
				mul r1.rgb, t0, v0
		mad_sat r0.rgb, r0.a, c1, c0
			+mul_sat r1.a, t2.a, r1.a
			mad r0.rgb, r1.a, c2, r0
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2

		; multiply lighting by material
		mul r0.rgb, r1, r0
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_1lights_opaque_shadow" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// shadow map
		tex t3	// light map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r0.rgb = (N dot -sun)*sun.color*shadow + ambient
		dp3_sat r0, t1_bx2, r0
			; r0.rgb += (N dot -L0) *L0.atten*L0.color
			dp3_sat r1, t1_bx2, t3_bx2
				; r1.rgb = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, t2.a, r0.a
		mad_sat r0.rgb, r0.a, c1, c0
			+mul_sat r1.a, t3.a, r1.a
			mad r0.rgb, r1.a, c2, r0
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2

		; multiply lighting by material
		mul r0.rgb, r1, r0
	</pixelshader>


	<pixelshader name="ps1_near_pixellit_1lights_hardedged" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// light map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r0.rgb = (N dot -sun)*sun.color + ambient
		dp3_sat r0, t1_bx2, r0
			; r0.rgb += (N dot -L0) *L0.atten*L0.color
			dp3_sat r1, t1_bx2, t2_bx2
		mad_sat r0.rgb, r0, c1, c0
			+mul_sat r0.a, r1.a, t2.a
			mad r0.rgb, r0.a, c2, r0
			+add r0.a,t0_bias.a,c7.b
	
		; multiply lighting by material
		mul r1.rgb, t0, v0
		+cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
		mul r0.rgb, r1, r0
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_1lights_hardedged_shadow" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // normal map
		tex t2	// shadow map
		tex t3	// light map

		// renormalize sun vector using n' = [(3 - n.n) / 2 ] * n
		dp3_d2 r0.rgb, v1_bx2, v1_bx2
		mad r0.rgb, -v1_bx2, r0_bias, v1_bx2

		; r0.rgb = (N dot -sun)*sun.color*shadow
		dp3_sat r0, t1_bx2, r0
			; r0.rgb += (N dot -L0) *L0.atten*L0.color + ambient
			dp3_sat r1, t1_bx2, t3_bx2
				; r1.rgb = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, r0.a, t2.a
		mad_sat r0.rgb, r0.a, c1, c0
			+mul_sat r1.a, r1.a, t3.a
			mad r0.rgb, r1.a, c2, r0
		+add r0.a,t0_bias.a,c7.b

		; multiply lighting by material
		mul r0.rgb, r1, r0
		+cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>
	
	<pixelshader name="ps1_near_pixellit_2lights_nosun_opaque" target="ps_1_1">
		// c2 -> light 0 color
		// c3 -> light 1 color

		tex t0	// diffuse map
		tex t1  // bump map
		tex t2	// light map
		tex t3	// light map

		; r0.rgb = (N dot -L0) *L0.atten*L0.color
		dp3_sat r0, t1_bx2, t2_bx2
			; r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1, t1_bx2, t3_bx2
				; r1.rgb = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, r0.a, t2.a
		mul r0.rgb, r0.a, c2
			+mul_sat r1.a, r1.a, t3.a
			mad r0.rgb, r1.a, c3, r0

		; multiply by material color
		mul r0.rgb, r1, r0
		mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_2lights_nosun_hardedged" target="ps_1_1">
		// c2 -> light 0 color
		// c3 -> light 1 color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // bump map
		tex t2	// light map
		tex t3	// light map

		; r0.rgb = (N dot -L0) *L0.atten*L0.color
		dp3_sat r0, t1_bx2, t2_bx2
			; r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1, t1_bx2, t3_bx2
				; r1.rgb = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, r0.a, t2.a
		mul r0.rgb, r0.a, c2
			+mul_sat r1.a, r1.a, t3.a
			mad r0.rgb, r1.a, c3, r0
		+add r0.a,t0_bias.a,c7.b

		; multiply by material color
		mul r0.rgb, r1, r0
		+cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_0lights_staticlit_opaque" target="ps_1_1">
		tex t0	// diffuse map

		mul r0.rgb, t0, v0
		+mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_0lights_staticlit_hardedged" target="ps_1_1">
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map

		mul r0.rgb, t0, v0
		+add r0.a,t0_bias.a,c7.b
		cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_2lights_staticlit_opaque" target="ps_1_1">
		// c2 -> light 0 color
		// c3 -> light 1 color

		tex t0	// diffuse map
		tex t1  // bump map
		tex t2	// light map
		tex t3	// light map

		; r0.rgb = (N dot -L0) *L0.atten*L0.color
		dp3_sat r0, t1_bx2, t2_bx2
			; r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1, t1_bx2, t3_bx2
				; r1 = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, r0.a, t2.a
		mad r0.rgb, r0.a, c2, v1
			+mul_sat r1.a, r1.a, t3.a
			mad r0.rgb, r1.a, c3, r0

		; multiply by diffuse color
		mul r0.rgb, r0, r1
		mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_2lights_staticlit_hardedged" target="ps_1_1">
		// c2 -> light 0 color
		// c3 -> light 1 color
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// diffuse map
		tex t1  // bump map
		tex t2	// light map
		tex t3	// light map

		; r0.rgb = (N dot -L0) *L0.atten*L0.color
		dp3_sat r0, t1_bx2, t2_bx2
			; r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1, t1_bx2, t3_bx2
				; r1 = diffuse texture * material color
				mul r1.rgb, t0, v0
		+mul_sat r0.a, r0.a, t2.a
		mad r0.rgb, r0.a, c2, v1
			+mul_sat r1.a, r1.a, t3.a
			mad r0.rgb, r1.a, c3, r0
		+add r0.a,t0_bias.a,c7.b

		; multiply by diffuse color
		mul r0.rgb, r0, r1
		cnd_x4 r0.a,r0.a,v0_bias.a,c7.a	// alpha test vs. alpharef; near scene alpha is d4 + 1/2
	</pixelshader>

	<pixelshader name="ps1_near_pixellit_specular_opaque" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c4 -> specular weights

		tex t0						// normal map (gloss map in alpha channel)
		texm3x3pad t1, t0_bx2
		texm3x3pad t2, t0_bx2
		texm3x3tex t3, t0_bx2		// look up specular values using light space normal

		// combine weighted average of 4 specular values
		dp3 r0, t3, c4
		mad r0, t3.a, c4.a, r0

		// r0.rgb = GLOSS*LIGHT_COLOR*COLOR_SPECULAR * (N dot H)^n
		mul r0.rgb, r0, v1
		mul r0.rgb, r0, c1
		mul r0.rgb, r0, t0.a
	</pixelshader>


	<pixelshader name="ps1_near_2lights" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color
		def c6, 0, 0, 0, 1
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// normal map
		tex t1	// light map
		tex t2  // light map
		;v0.rgb = vertex lighting

		; light 0: r0.rgb = (N dot -L0) *L0.atten*L0.color + vertexlighting
		dp3_sat r0, t0_bx2, t1_bx2
			; light 1: r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1.rgb, t0_bx2, t2_bx2
		+mul_sat r0.a, r0.a, t1.a
		mad_sat r0.rgb, r0.a, c0, v1
			+mul_sat r0.a, r1.b, t2.a
			mad_sat r0.rgb, r0.a, c1, r0
		; write 1 to output
		+mov r0.a, c6.a
	</pixelshader>

	<pixelshader name="ps1_near_3lights" target="ps_1_1">
		// c0 -> ambient color
		// c1 -> sun color
		// c2 -> light 0 color
		def c6, 0, 0, 0, 1
		def c7, 0, 0, 0.5, -0.01		// 0, 0, 1-alpharef, 0

		tex t0	// normal map
		tex t1	// light map
		tex t2  // light map
		tex t3	// light map
		;v0.rgb = vertex lighting

		; light 0: r0.rgb = (N dot -L0) *L0.atten*L0.color + vertexlighting
		dp3_sat r0, t0_bx2, t1_bx2
			; light 1: r0.rgb += (N dot -L1) *L1.atten*L1.color
			dp3_sat r1.rgb, t0_bx2, t2_bx2
		+mul_sat r0.a, r0.a, t1.a
		mad_sat r0.rgb, r0.a, c0, v1
			+mul_sat r0.a, r1.b, t2.a
		; light 2: r0.rgb += (N dot -L2) *L2.atten*L2.color
		dp3_sat r1.rgb, t0_bx2, t2_bx2
			mad_sat r0.rgb, r0.a, c1, r0
		+mul_sat r1.a, r1.b, t2.a
		mad_sat r0.rgb, r1.a, c2, r0
		+mov r0.a, c6.a
	</pixelshader>





	<pixelshader name="ps1_debug" target="ps_1_1">
		texcoord t0
		mov r0.rgb, t0
		mov_x4 r0.a,v0_bias.a		// near scene alpha is d4 + 1/2
	</pixelshader>

	<!-- ****************************** States ****************************** -->

	<pipeline id="1">

		<!-- Vertex lit normal states -->

		<state id="0">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_far"/>
				<pixelshader use="ps1_far"/>
			</pass>
		</state>
		<state id="1">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque"/>
				<pixelshader use="ps1_near_opaque"/>
			</pass>
		</state>
		<state id="2">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque"/>
				<pixelshader use="ps1_near_hardedged"/>
			</pass>
		</state>
		<state id="3">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent"/>
				<pixelshader use="ps1_near_transparent"/>
			</pass>
		</state>
		<state id="4">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent"/>
				<pixelshader use="ps1_near_transparent_hardedged"/>
			</pass>
		</state>
		<state id="5">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque_shadow"/>
				<pixelshader use="ps1_near_opaque_shadow"/>
			</pass>
		</state>
		<state id="6">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque_shadow"/>
				<pixelshader use="ps1_near_hardedged_shadow"/>
			</pass>
		</state>
		<state id="7">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent_shadow"/>
				<pixelshader use="ps1_near_transparent_shadow"/>
			</pass>
		</state>
		<state id="8">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent_shadow"/>
				<pixelshader use="ps1_near_transparent_hardedged_shadow"/>
			</pass>
		</state>


		<!-- Vertex Lit specular states -->

		<state id="9">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque_specular"/>
				<pixelshader use="ps1_near_opaque_specular"/>
			</pass>
		</state>
		<state id="10">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent_specular"/>
				<pixelshader use="ps1_near_transparent_specular"/>
			</pass>
		</state>
		<state id="11">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_opaque_specular_shadow"/>
				<pixelshader use="ps1_near_opaque_specular_shadow"/>
			</pass>
		</state>
		<state id="12">
			<pass transform="normals" lighting="diffuse">
				<vertexshader use="vs1_near_transparent_specular_shadow"/>
				<pixelshader use="ps1_near_transparent_specular_shadow"/>
			</pass>
		</state>


		<!-- Pixel lit normal states -->

		<state id="13">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_0lights_opaque"/>
			</pass>
		</state>

		<state id="14">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque"/>
			</pass>
		</state>

		<state id="15">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>
		</state>

		<state id="16">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_0lights_hardedged"/>
			</pass>
		</state>

		<state id="17">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_hardedged"/>
			</pass>
		</state>

		<state id="18">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_hardedged"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_hardedged"/>
			</pass>
		</state>

		<state id="19">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_0lights_opaque_shadow"/>
			</pass>
		</state>

		<state id="20">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque_shadow"/>
			</pass>
		</state>

		<state id="21">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque_shadow"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>
		</state>

		<state id="22">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_0lights_hardedged_shadow"/>
			</pass>
		</state>

		<state id="23">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_hardedged_shadow"/>
			</pass>
		</state>

		<state id="24">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_hardedged_shadow"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_hardedged"/>
			</pass>
		</state>


		<!-- Pixel lit staticlit states -->

		<state id="25">
			<pass transform="position" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_0lights_staticlit_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_0lights_staticlit_opaque"/>
			</pass>
		</state>

		<state id="26">
			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_staticlit_opaque"/>
			</pass>
		</state>

		<state id="27">
			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_staticlit_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>
		</state>

		<state id="28">
			<pass transform="position" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_0lights_staticlit_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_0lights_staticlit_hardedged"/>
			</pass>
		</state>

		<state id="29">
			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_staticlit_hardedged"/>
			</pass>
		</state>

		<state id="30">
			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_staticlit_hardedged"/>
			</pass>

			<pass transform="binormals" lighting="none" vertexcolor="yes">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_hardedged"/>
			</pass>
		</state>

		<!-- Pixel Lit specular states -->

		<state id="31">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_0lights_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="32">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="33">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="34">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_0lights_opaque_shadow"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="35">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque_shadow"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="36">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_1light_near_opaque_shadow"/>
				<pixelshader use="ps1_near_pixellit_1lights_opaque_shadow"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_2lights_nosun_near_opaque"/>
				<pixelshader use="ps1_near_pixellit_2lights_nosun_opaque"/>
			</pass>

			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_pixellit_near_opaque_specular"/>
				<pixelshader use="ps1_near_pixellit_specular_opaque"/>
			</pass>
		</state>

		<state id="37">
			<pass transform="binormals" lighting="none">
				<vertexshader use="vs1_debug"/>
				<pixelshader use="ps1_debug"/>
			</pass>
		</state>
	</pipeline>
</shader>